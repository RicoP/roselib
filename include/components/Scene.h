///////////////////////////////////////////////////////////////////
// AUTOGENERATED do not edit by hand                             //
///////////////////////////////////////////////////////////////////
#pragma once
#include <components/computils.h>
#include <serializer/serializer.h>
#include <rose/ecs.h>
#include <cstring>

#include <components/camera.h>
#include <components/hero.h>
#include <components/kraxler.h>
#include <components/kraxlersystemstate.h>
#include <components/microsystem.h>
#include <components/sceneobject.h>
#include <components/raytracer.h>
#include <components/wheelchairsystemstate.h>
namespace rose {
namespace ecs {
struct Scene {
  int activeCamera;
  rose::vectorPOD<16, Camera> cameras;
  Hero hero;
  Kraxler kraxler;
  KraxlerSystemState kraxlerSystem;
  rose::vectorPOD<16, MicroSystem> microSystems;
  rose::string<128> name;
  rose::vectorPOD<1024, SceneObject> objects;
  Raytracer raytracer;
  WheelchairSystemState wheelchairSystem;

  bool equals(const Scene & rhs) const {
    return
      activeCamera == rhs.activeCamera &&
      cameras == rhs.cameras &&
      hero == rhs.hero &&
      kraxler == rhs.kraxler &&
      kraxlerSystem == rhs.kraxlerSystem &&
      microSystems == rhs.microSystems &&
      name == rhs.name &&
      objects == rhs.objects &&
      raytracer == rhs.raytracer &&
      wheelchairSystem == rhs.wheelchairSystem;
  }
};

inline void construct_defaults(Scene & o) {
  std::memset(&o, 0, sizeof(Scene));
  o.activeCamera = 1;
  o.cameras.size = 0;
  construct_defaults(o.hero);
  construct_defaults(o.kraxler);
  construct_defaults(o.kraxlerSystem);
  o.microSystems.size = 0;
  o.objects.size = 0;
  construct_defaults(o.raytracer);
  construct_defaults(o.wheelchairSystem);
}

inline bool operator==(const Scene &lhs, const Scene &rhs) {
  return lhs.equals(rhs);
}

inline bool operator!=(const Scene &lhs, const Scene &rhs) {
  return !lhs.equals(rhs);
}

///////////////////////////////////////////////////////////////////
// serializer                                                    //
///////////////////////////////////////////////////////////////////
inline void serialize(Scene &o, ISerializer &s) {
  if(s.node_begin("Scene", rose::hash("Scene"), &o)) {
    s.key("activeCamera");
    serialize(o.activeCamera, s);
    s.key("cameras");
    serialize(o.cameras, s);
    s.key("hero");
    serialize(o.hero, s);
    s.key("kraxler");
    serialize(o.kraxler, s);
    s.key("kraxlerSystem");
    serialize(o.kraxlerSystem, s);
    s.key("microSystems");
    serialize(o.microSystems, s);
    s.key("name");
    serialize(o.name, s);
    s.key("objects");
    serialize(o.objects, s);
    s.key("raytracer");
    serialize(o.raytracer, s);
    s.key("wheelchairSystem");
    serialize(o.wheelchairSystem, s);
    s.node_end();
  }
  s.end();
}

///////////////////////////////////////////////////////////////////
// deserializer                                                  //
///////////////////////////////////////////////////////////////////
inline void deserialize(Scene &o, IDeserializer &s) {
  construct_defaults(o);

  while (s.next_key()) {
    switch (s.hash_key()) {
      case rose::hash("activeCamera"):
        deserialize(o.activeCamera, s);
        break;
      case rose::hash("cameras"):
        deserialize(o.cameras, s);
        break;
      case rose::hash("hero"):
        deserialize(o.hero, s);
        break;
      case rose::hash("kraxler"):
        deserialize(o.kraxler, s);
        break;
      case rose::hash("kraxlerSystem"):
        deserialize(o.kraxlerSystem, s);
        break;
      case rose::hash("microSystems"):
        deserialize(o.microSystems, s);
        break;
      case rose::hash("name"):
        deserialize(o.name, s);
        break;
      case rose::hash("objects"):
        deserialize(o.objects, s);
        break;
      case rose::hash("raytracer"):
        deserialize(o.raytracer, s);
        break;
      case rose::hash("wheelchairSystem"):
        deserialize(o.wheelchairSystem, s);
        break;
      default: s.skip_key(); break;
    }
  }
}

///////////////////////////////////////////////////////////////////
// randomize                                                     //
///////////////////////////////////////////////////////////////////
inline void randomize(Scene &o, rose::hash_value & h) {
  randomize(o.activeCamera, h);
  randomize(o.cameras, h);
  randomize(o.hero, h);
  randomize(o.kraxler, h);
  randomize(o.kraxlerSystem, h);
  randomize(o.microSystems, h);
  randomize(o.name, h);
  randomize(o.objects, h);
  randomize(o.raytracer, h);
  randomize(o.wheelchairSystem, h);
}
} //namespace ecs

///////////////////////////////////////////////////////////////////
// hashing                                                       //
///////////////////////////////////////////////////////////////////
  inline hash_value hash(const ecs::Scene &o) {
    hash_value h = hash(o.activeCamera);
    h = xor64(h);
    h ^= hash(o.cameras);
    h = xor64(h);
    h ^= hash(o.hero);
    h = xor64(h);
    h ^= hash(o.kraxler);
    h = xor64(h);
    h ^= hash(o.kraxlerSystem);
    h = xor64(h);
    h ^= hash(o.microSystems);
    h = xor64(h);
    h ^= hash(o.name);
    h = xor64(h);
    h ^= hash(o.objects);
    h = xor64(h);
    h ^= hash(o.raytracer);
    h = xor64(h);
    h ^= hash(o.wheelchairSystem);
    return h;
  }
} //namespace rose
