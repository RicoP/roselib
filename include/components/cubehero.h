///////////////////////////////////////////////////////////////////
// AUTOGENERATED do not edit by hand                             //
///////////////////////////////////////////////////////////////////
#pragma once
#include <components/computils.h>
#include <serializer/serializer.h>
#include <cstring>

#include <components/vector3.h>
#include <components/vector3.h>
namespace rose {
struct Cubehero {
  vector3 destination;
  vector3 position;
  int state;
  int waypoint;

  bool equals(const Cubehero & rhs) const {
    return
      destination == rhs.destination &&
      position == rhs.position &&
      state == rhs.state &&
      waypoint == rhs.waypoint;
  }
};

inline void construct_defaults(Cubehero & o) {
  std::memset(&o, 0, sizeof(Cubehero));
  construct_defaults(o.destination);
  construct_defaults(o.position);
  o.state = 0;
  o.waypoint = 0;
}

inline bool operator==(const Cubehero &lhs, const Cubehero &rhs) {
  return lhs.equals(rhs);
}

inline bool operator!=(const Cubehero &lhs, const Cubehero &rhs) {
  return !lhs.equals(rhs);
}

///////////////////////////////////////////////////////////////////
// serializer                                                    //
///////////////////////////////////////////////////////////////////
inline void serialize(Cubehero &o, ISerializer &s) {
  if(s.node_begin("Cubehero", rose::hash("Cubehero"), &o)) {
    s.key("destination");
    serialize(o.destination, s);
    s.key("position");
    serialize(o.position, s);
    s.key("state");
    serialize(o.state, s);
    s.key("waypoint");
    serialize(o.waypoint, s);
    s.node_end();
  }
  s.end();
}

///////////////////////////////////////////////////////////////////
// deserializer                                                  //
///////////////////////////////////////////////////////////////////
inline void deserialize(Cubehero &o, IDeserializer &s) {
  construct_defaults(o);

  while (s.next_key()) {
    switch (s.hash_key()) {
      case rose::hash("destination"):
        deserialize(o.destination, s);
        break;
      case rose::hash("position"):
        deserialize(o.position, s);
        break;
      case rose::hash("state"):
        deserialize(o.state, s);
        break;
      case rose::hash("waypoint"):
        deserialize(o.waypoint, s);
        break;
      default: s.skip_key(); break;
    }
  }
}

///////////////////////////////////////////////////////////////////
// randomize                                                     //
///////////////////////////////////////////////////////////////////
inline void randomize(Cubehero &o, rose::hash_value & h) {
  randomize(o.destination, h);
  randomize(o.position, h);
  randomize(o.state, h);
  randomize(o.waypoint, h);
}

///////////////////////////////////////////////////////////////////
// hashing                                                       //
///////////////////////////////////////////////////////////////////
  inline hash_value hash(const Cubehero &o) {
    hash_value h = hash(o.destination);
    h = xor64(h);
    h ^= hash(o.position);
    h = xor64(h);
    h ^= hash(o.state);
    h = xor64(h);
    h ^= hash(o.waypoint);
    return h;
  }
} //namespace rose
