import os

bindings = [
	#BINDING(events, void, push, (void * data, int size), (data, size) )
	# namespace type    name  args: [ [type, name], ... ]
	[ "internal", "void *", "create_or_fetch_worldstate", [ ["const rose::reflection::TypeInfo &", "type"] ] ],
	[ "internal", "void", "register_singleton_class_instance", [ ["rose::hash_value", "type_id"], ["void *", "instance"] ] ],
	[ "internal", "void", "unregister_singleton_class_instance", [ ["rose::hash_value", "type_id"], ["void *", "instance"] ] ],
	[ "internal", "void *", "get_singleton_class_instance", [ ["rose::hash_value", "type_id"] ] ],
	[ "filewatcher", "int", "watch_path", [ ["const char *", "path"] ] ],
	[ "filewatcher", "bool", "unwatch_path", [ ["int", "id"] ] ],
]

# a custom made hash function for python strings that stays consistent between runs
def chash(obj):
	s = str(obj)
	h = 0
	for c in s:
		h = (h + ord(c)) % (2 ** 32)
	return h

def write_header(f):
	f.write("#pragma once\n")
	f.write("\n")
	f.write("///////////////////////////////////////////////////\n")
	f.write("// AUTOGENERATED: \n")
	f.write("// DO NOT EDIT THIS FILE\n")
	f.write("// EDIT: roselib/internal/generate_bindings.py\n")
	f.write("// Bindings hash: " + str(chash(bindings)) + "\n")
	f.write("///////////////////////////////////////////////////\n")
	f.write("#include <rose/hash.h>\n")
	f.write("\n")

# create file file bindings_engine.h.tmp
with open("bindings_typedef.h.tmp", "w") as f:
	write_header(f)

	for binding in bindings:
		#typedef Pad (*input_pad_ft)();
		f.write("typedef ")
		f.write(binding[1])
		f.write(" (*rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("_ft)(int")
		for arg in binding[3]:
			f.write(", ")
			f.write(arg[0])
			f.write(" ")
			f.write(arg[1])
		f.write(");\n")

	f.close()
	os.replace("bindings_typedef.h.tmp", "bindings_typedef.h")

with open("bindings_subsystem.h.tmp", "w") as f:
	write_header(f)
	f.write("#include <roselib/context.h>\n")
	f.write("#include <rose/internal/bindings_typedef.h>\n")

	for binding in bindings:
		#ROSE_EXPORT input_pad_ft c_input_pad;
		f.write("ROSE_EXPORT rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("_ft c_")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write(";\n")
	
	f.write("ROSE_EXPORT int c_rose_subsystem_instance_id; \n")



	f.write("\n#ifdef __cplusplus\n")
	f.write("namespace rose {\n")
	for binding in bindings:
		if(binding[0] == "internal"):
			continue
		#namespace rose {
		#namespace input {
		#	pad pad() {
		# 		return c_input_pad();
		#	}
		#}
		#}
		f.write("namespace ")
		f.write(binding[0])
		f.write(" {\n")
		f.write("  inline ")
		f.write(binding[1])
		f.write(" ")
		f.write(binding[2])
		f.write("(")
		for arg in binding[3]:
			f.write(arg[0])
			f.write(" ")
			f.write(arg[1])
			f.write(", ") if arg != binding[3][-1] else f.write(") {\n")
		f.write("    ")
		f.write("return "  if binding[1] != "void" else "")
		f.write("c_rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("(c_rose_subsystem_instance_id")
		for arg in binding[3]:
			f.write(", ")
			f.write(arg[1])
		f.write(");\n")
		f.write("  }\n")
		f.write("}\n")

	f.write("}\n")
	f.write("#endif\n")

	f.close()
	os.replace("bindings_subsystem.h.tmp", "bindings_subsystem.h")


# create file file bindings_engine.h.tmp
with open("bindings_engine.h.tmp", "w") as f:
	write_header(f)
	f.write("#include <rose/internal/bindings_typedef.h>\n")

	f.write("\nnamespace subsystem_bindings {\n")

	#for each binding 
	#print float g_rose_utils_add(float a, float b);
	for binding in bindings:
		f.write(binding[1])
		f.write(" ")
		f.write("g_rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("(int")
		for arg in binding[3]:
			f.write(", ")
			f.write(arg[0])
			f.write(" ")
			f.write(arg[1])
		f.write(");\n")
	f.write("}\n\n")

	f.write("template<class Lambda1, class Lambda2>\n")
	f.write("void inject_bindings(Lambda1 get_symbol_address, Lambda2 not_found_cb) {\n")
	#iteartor over bindings and create the string
	#{
	#	auto fun = (input_pad_ft*)(GetProcAddress(lib, "c_input_pad"));
	#	if(fun) {
	#		*fun = g_input_pad;
	#	} else {
	#		std::fprintf(stderr, "Warning: Couldn't find function %s \n", "c_input_pad");
	#	}
	#}
	for binding in bindings:
		f.write("  {")
		f.write("\n    auto fun = (")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("_ft*)(get_symbol_address(\"c_")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("\"));\n")
		f.write("    if(fun) {\n")
		f.write("      *fun = subsystem_bindings::g_rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write(";\n    } else {\n")
		f.write("      not_found_cb(\"c_")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("\");\n    }\n")
		f.write("  }\n")
		
	f.write("}\n")

	f.close()
	os.replace("bindings_engine.h.tmp", "bindings_engine.h")

with open("bindings_impl.h.tmp", "w") as f:
	write_header(f)
	f.write("#include <rose/internal/bindings_typedef.h>\n")

	f.write("//TODO: consider adding fake stubs for the functions that throw.\n")

	for binding in bindings:
		#static rose_input_pad_ft rose_input_pad = 0;
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("_ft c_")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write(" = 0;\n")

	f.close()
	os.replace("bindings_impl.h.tmp", "bindings_impl.h")