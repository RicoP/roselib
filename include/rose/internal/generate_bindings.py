import os

bindings = [
	#BINDING(events, void, push, (void * data, int size), (data, size) )
	# namespace type    name  args: [ [type, name], ... ]
	#[ "events", "void", "push", [ ["void*", "data"], ["int", "size"] ] ]
	[ "internal", "rose::EventQueue*", "get_event_queue", [ ] ],
	[ "filewatcher", "int", "watch_path", [ ["const char *", "path"] ] ],
	[ "filewatcher", "bool", "unwatch_path", [ ["int", "id"] ] ],
]

blacklist = [ ("internal", "get_event_queue") ]

# a custom made hash function for python strings that stays consistent between runs
def chash(obj):
	s = str(obj)
	h = 0
	for c in s:
		h = (h + ord(c)) % (2 ** 32)
	return h

def write_header(f):
	f.write("#pragma once\n")
	f.write("\n")
	f.write("////////////////////////////////////////\n")
	f.write("// AUTOGENERATED: \n")
	f.write("// DO NOT EDIT THIS FILE\n")
	f.write("// EDIT: roselib/internal/generate_bindings.py\n")
	f.write("// Bindings hash: " + str(chash(bindings)) + "\n")
	f.write("///////////////////////////////////////////////////\n")
	f.write("#include <roselib/context.h>\n")
	f.write("#include <rose/hash.h>\n")
	f.write("#include <cstdio>\n")
	f.write("\n")


# create file file bindings.h.tmp
with open("bindings.h.tmp", "w") as f:
	write_header(f)

	for binding in bindings:
		#typedef Pad (*input_pad_ft)();
		f.write("typedef ")
		f.write(binding[1])
		f.write(" (*rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("_ft)(")
		for arg in binding[3]:
			f.write(arg[0])
			f.write(" ")
			f.write(arg[1])
			f.write(", ") if arg != binding[3][-1] else f.write("")
		f.write(");\n")

	f.write("\n#ifndef ROSE_ENGINE_INTERNAL\n")

	for binding in bindings:
		#ROSE_EXPORT input_pad_ft c_input_pad;
		f.write("ROSE_EXPORT rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("_ft c_")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write(";\n")

	f.write("\n#ifdef __cplusplus\n")
	f.write("namespace rose {\n")
	for binding in bindings:
		name_tuple = binding[0], binding[2]
		if(name_tuple in blacklist):
			continue
		#namespace rose {
		#namespace input {
		#	pad pad() {
		# 		return c_input_pad();
		#	}
		#}
		#}
		f.write("namespace ")
		f.write(binding[0])
		f.write(" {\n")
		f.write("  inline ")
		f.write(binding[1])
		f.write(" ")
		f.write(binding[2])
		f.write("(")
		for arg in binding[3]:
			f.write(arg[0])
			f.write(" ")
			f.write(arg[1])
			f.write(", ") if arg != binding[3][-1] else f.write(") {\n")
		f.write("    ")
		f.write("return "  if binding[1] != "void" else "")
		f.write("c_rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("(")
		for arg in binding[3]:
			f.write(arg[1])
			f.write(", ") if arg != binding[3][-1] else f.write("")
		f.write(");\n")
		f.write("  }\n")
		f.write("}\n")

	#some custom functions
	f.write("namespace event {\n")
	f.write("  template<class T> \n")
	f.write("  void broadcast(const T & event) {\n")
	f.write("    c_rose_internal_get_event_queue().push_back(event);\n")
	f.write("  }\n")
	f.write("}\n")
	f.write("}\n")
	f.write("#endif\n")

	f.write("\n#else\n")
	f.write("\n#ifdef _WIN32\n")
	f.write("#include <windows.h>\n")
	f.write("#endif\n")

	f.write("\nnamespace subsystem_bindings {\n")

	#for each binding 
	#print float g_rose_utils_add(float a, float b);
	for binding in bindings:
		f.write(binding[1])
		f.write(" ")
		f.write("g_rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("(")
		for arg in binding[3]:
			f.write(arg[0])
			f.write(" ")
			f.write(arg[1])
			f.write(", ") if arg != binding[3][-1] else f.write("")
		f.write(");\n")
	f.write("}\n\n")

	f.write("//TODO: create unix binding.\n")
	f.write("inline void inject_bindings(HMODULE handle) { \n")
	#iteartor over bindings and create the string
	#{
	#	auto fun = (input_pad_ft*)(GetProcAddress(lib, "c_input_pad"));
	#	if(fun) {
	#		*fun = g_input_pad;
	#	} else {
	#		std::fprintf(stderr, "Warning: Couldn't find function %s \n", "c_input_pad");
	#	}
	#}
	for binding in bindings:
		f.write("  {")
		f.write("\n    auto fun = (")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("_ft*)(GetProcAddress(handle, \"c_")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("\"));\n")
		f.write("    if(fun) {\n")
		f.write("      *fun = subsystem_bindings::g_rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write(";\n    } else {\n")
		f.write("      std::fprintf(stderr, \"Warning: Couldn't find function %s \\n\", \"c_")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("\");\n    }\n")
		f.write("  }\n")
		
	f.write("}\n")
	f.write("#endif\n\n")

	f.close()
	os.replace("bindings.h.tmp", "bindings.h")

with open("bindings_impl.h.tmp", "w") as f:
	write_header(f)
	f.write("#include <rose/internal/bindings.h>\n")
	f.write("//TODO: consider adding fake stubs for the functions that throw.\n")

	for binding in bindings:
		#static rose_input_pad_ft rose_input_pad = 0;
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write("_ft c_")
		f.write("rose_")
		f.write(binding[0])
		f.write("_")
		f.write(binding[2])
		f.write(" = 0;\n")

	f.close()
	os.replace("bindings_impl.h.tmp", "bindings_impl.h")