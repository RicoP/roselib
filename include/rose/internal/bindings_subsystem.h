#pragma once

///////////////////////////////////////////////////
// AUTOGENERATED: 
// DO NOT EDIT THIS FILE
// EDIT: roselib/internal/generate_bindings.py
// Bindings hash: 24331
///////////////////////////////////////////////////
#include <rose/hash.h>
#include <rose/world.h>
#include <rose/eventqueue.h>
#include <rose/internal/singletonregister.h>

#include <roselib/context.h>
#include <rose/internal/bindings_typedef.h>
#include <rose/internal/singletonregister.h>
ROSE_EXPORT rose_internal_get_event_queue_ft c_rose_internal_get_event_queue;
ROSE_EXPORT rose_internal_create_or_fetch_worldstate_ft c_rose_internal_create_or_fetch_worldstate;
ROSE_EXPORT rose_filewatcher_watch_path_ft c_rose_filewatcher_watch_path;
ROSE_EXPORT rose_filewatcher_unwatch_path_ft c_rose_filewatcher_unwatch_path;
ROSE_EXPORT int c_rose_subsystem_instance_id; 

#ifdef __cplusplus
namespace rose {
namespace internal {
  inline void * create_or_fetch_worldstate(const rose::reflection::TypeInfo & type) {
    return c_rose_internal_create_or_fetch_worldstate(c_rose_subsystem_instance_id, type);
  }
}
namespace filewatcher {
  inline int watch_path(const char * path) {
    return c_rose_filewatcher_watch_path(c_rose_subsystem_instance_id, path);
  }
}
namespace filewatcher {
  inline bool unwatch_path(int id) {
    return c_rose_filewatcher_unwatch_path(c_rose_subsystem_instance_id, id);
  }
}
namespace event {
  template<class T> 
  void broadcast(const T & event) {
    c_rose_internal_get_event_queue()->push_back(event);
  }
}
}
#endif
